import TestModule from "./Test.js";
const Test = new TestModule();

/**
     Harvest Festival
    You have cultivated a plant, and after three long months, the time has come to reap the fruits (or the flowers, in this case) of your hard work. During the growth phase, you added water and fertilizer, and kept a constant temperature. It's time to check how much the plant has grown!

    A plant is represented horizontally, from the base to the left, to the end to the right:

    ---@---@---@
    The stem is made of hyphens, and the flowers are represented by symbols. A plant always starts with the stem, and always ends with flowers.
    The four given parameters are:

    seed (string) determines the type of flowers generated by the plant.
    water (integer) each unit of water extends the portion of stem between the flowers, and gives the total number of segments (stem + flowers) of the plant.
    fert (integer) each unit of fertilizer increases the amount of flowers, grouped in clusters.
    temp (integer) if the temperature recorded is between 20°C and 30°C (bounds included) the plant grows normally, otherwise all the flowers die, except for a single survivor at the end of the stem.
    Given the above parameters, implement a function that returns a string representing the plant (see the examples below for a better visualization).

    Examples
    plant("@", 3, 3, 25) ➞ "---@@@---@@@---@@@"
    // Water gives the length of the stem portions between flowers.
    // Water gives the total number of segments.
    // Fertilizer gives the length of flowers clusters.
    // In this case the temperature is in the acceptable range 20°C | 30°C

    plant("#", 1, 5, 30) ➞ "-#####"
    plant("&", 5, 1, 20) ➞ "-----&-----&-----&-----&-----&"
    plant("§", 3, 3, 15) ➞ "---------§"
    // The temperature out of range make all flowers die, except the last one.
    // The stem is not affected by temperature.
 */

function plant(seed, water, fert, temp) {
  const root = water;
  const flower = seed;
  let plant = "";
  const isSafeTemp = temp <= 30 && temp >= 20;

  for (let w = 0; w < water; w++) {
    for (let r = 0; r < root; r++) {
      plant += "-";
    }
    if (isSafeTemp) {
      for (let f = 0; f < fert; f++) {
        plant += seed;
      }
    }
  }

  if (!isSafeTemp) {
    plant += seed;
  }

  return plant;
}

Test.assertEquals(plant("@", 3, 3, 25), "---@@@---@@@---@@@", "Example #1");
Test.assertEquals(plant("#", 1, 5, 30), "-#####", "Example #2");
Test.assertEquals(
  plant("§", 5, 1, 20),
  "-----§-----§-----§-----§-----§",
  "Example #3"
);
Test.assertEquals(plant("&", 3, 3, 15), "---------&", "Example #4");
Test.assertEquals(plant("🍁", 2, 6, 28), "--🍁🍁🍁🍁🍁🍁--🍁🍁🍁🍁🍁🍁");
Test.assertEquals(plant("🍃", 4, 2, 22), "----🍃🍃----🍃🍃----🍃🍃----🍃🍃");
Test.assertEquals(plant("€", 4, 10, 38), "----------------€");

/**
     Broken Keyboard
    Given what is supposed to be typed and what is actually typed, write a function that returns the broken key(s). The function looks like:

    findBrokenKeys(correct phrase, what you actually typed)
    Examples
    findBrokenKeys("happy birthday", "hawwy birthday") ➞ ["p"]
    findBrokenKeys("starry night", "starrq light") ➞ ["y", "n"]
    findBrokenKeys("beethoven", "affthoif5") ➞ ["b", "e", "v", "n"]
 */

function findBrokenKeys(str1, str2) {
  const str1Arr = str1.split("");
  const str2Arr = str2.split("");

  const filteredLetters = str1Arr.filter(
    (letter, idx) => letter !== str2Arr[idx]
  );

  return Array.from(new Set(filteredLetters));
}

Test.assertSimilar(findBrokenKeys("happy birthday", "hawwy birthday"), ["p"]);
Test.assertSimilar(findBrokenKeys("starry night", "starrq light"), ["y", "n"]);
Test.assertSimilar(findBrokenKeys("beethoven", "affthoif5"), [
  "b",
  "e",
  "v",
  "n",
]);
Test.assertSimilar(findBrokenKeys("mozart", "aiwgvx"), [
  "m",
  "o",
  "z",
  "a",
  "r",
  "t",
]);
Test.assertSimilar(
  findBrokenKeys("5678", "4678"),
  ["5"],
  "It should work for numbers."
);
Test.assertSimilar(
  findBrokenKeys("!!??$$", "$$!!??"),
  ["!", "?", "$"],
  "It should work for punctuation."
);

/**
     Do All Bigrams Exist?
    You are given an input array of bigrams, and an array of words.

    Write a function that returns true if every single bigram from this array can be found at least once in an array of words.

    Examples
    canFind(["at", "be", "th", "au"], ["beautiful", "the", "hat"]) ➞ true
    canFind(["ay", "be", "ta", "cu"], ["maybe", "beta", "abet", "course"]) ➞ false
    # "cu" does not exist in any of the words.
    canFind(["th", "fo", "ma", "or"], ["the", "many", "for", "forest"]) ➞ true
    canFind(["oo", "mi", "ki", "la"], ["milk", "chocolate", "cooks"]) ➞ false
 */

function canFind(bigrams, words) {
  const isFound = bigrams.filter((bigram) => {
    return words.some((word) => {
      if (word.indexOf(bigram) !== -1) {
        return true;
      } else {
        return false;
      }
    });
  });

  return isFound.length === bigrams.length;
}

Test.assertEquals(
  canFind(["at", "be", "th", "au"], ["beautiful", "the", "hat"]),
  true
);
Test.assertEquals(
  canFind(["bo", "ta", "el", "st", "ca"], ["books", "table", "cap", "hostel"]),
  true
);
Test.assertEquals(canFind(["la", "te"], ["latte"]), true);
Test.assertEquals(
  canFind(["th", "fo", "ma", "or"], ["the", "many", "for", "forest"]),
  true
);
Test.assertEquals(
  canFind(["ay", "be", "ta", "cu"], ["maybe", "beta", "abet", "course"]),
  false
);
Test.assertEquals(
  canFind(["oo", "mi", "ki", "la"], ["milk", "chocolate", "cooks"]),
  false
);
Test.assertEquals(canFind(["la"], []), false);
Test.assertEquals(canFind(["la", "at", "te", "ea"], ["latte"]), false);
